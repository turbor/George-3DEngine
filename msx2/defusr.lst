# file opened: defusr.asm
  1   0000              ; routine to read and store integers in memory mapper pages
  2   0000              ; to store a value in a mapper: _usr0("VFFFF,FF33"), where
  3   0000              ; - the first char is a capital letter V..Z
  4   0000              ; - then the index in the array in capital hex
  5   0000              ; - a seperator that determines the end of the hex value, aka something that can't be used as an HEX digit :-)
  6   0000              ; - then the 16bit value to store
  7   0000              ;
  8   0000              ; to read a value in a mapper: _usr1("VFFFF"), where
  9   0000              ; - the first char is a capital letter V..Z
 10   0000              ; - then the index in the array
 11   0000              ;
 12   0000              ;
 13   0000              ; So you can do in basic _USR0("U"+hex$(c)+","+hex$(v))
 14   0000
 15   0000              DAC	equ 0xF7F6 ; 8 bytes containing the data of the variable
 16   0000              VALTYP	equ 0xF663 ; 1 byte indicate the type of variable in DAC
 17   0000              		;VALTYP can be
 18   0000              		; 2 = Integer
 19   0000              		;	DAC byte 0+1 is the 16bits integer
 20   0000              		; 3 = String
 21   0000              		;   DAC byte 2+3 is pointer to string descriptor
 22   0000              		;	  descriptor byte 0 is number of chars
 23   0000              		;	  descriptor byte 1+2 pointer to string storage
 24   0000              		; 4 = Single precision
 25   0000              		;	DAC byte 0+1+2+3 single precision real number
 26   0000              		; 8 = Double precision
 27   0000              		;	DAC byte 0..7 double precision real number
 28   0000
 29   0000
 30   0000              	org 0xd800
 31   D800
 32   D800 18 11        	jr store
 33   D802
 34   D802              retrieve:
 35   D802 CD 25 D8     	call set_mmpage_get_indx_ptr
 36   D805 5E           	ld e,(hl)	; read 16bit value at indx_ptr
 37   D806 23           	inc hl
 38   D807 56           	ld d,(hl)
 39   D808 ED 53 F8 F7  	ld (DAC+2),de	; store in DAC
 40   D80C 3E 02        	ld a,2
 41   D80E 32 63 F6     	ld (VALTYP),a	; set return type to int
 42   D811 18 0C        	jr back2basic
 43   D813
 44   D813              store:
 45   D813 CD 25 D8     	call set_mmpage_get_indx_ptr
 46   D816 E5           	push hl
 47   D817 CD 42 D8     	call converthex
 48   D81A EB           	ex de,hl
 49   D81B E1           	pop hl
 50   D81C 73           	ld (hl),e
 51   D81D 23           	inc hl
 52   D81E 72           	ld (hl),d
 53   D81F              back2basic:
 54   D81F 3E 01        	ld a,1
 55   D821 D3 FE        	out (0xFE),a
 56   D823 FB           	ei
 57   D824 C9           	ret
 58   D825
 59   D825              set_mmpage_get_indx_ptr:
 60   D825              	; get string pointer to interprete
 61   D825              	; no input validation simply assume it is a string...
 62   D825 2A F8 F7     	ld hl,(DAC+2)
 63   D828
 64   D828 46           	ld b,(hl)
 65   D829 23           	inc hl
 66   D82A 5E           	ld e,(hl)
 67   D82B 23           	inc hl
 68   D82C 56           	ld d,(hl)
 69   D82D EB           	ex de,hl
 70   D82E 7E           	ld a,(hl)
 71   D82F 05           	dec b
 72   D830 D6 53        	sub a,'V'-3 ; =>V=3,W=4,X=5,Y=6,Z=7
 73   D832 F3           	di
 74   D833 D3 FE        	out (#FE),a
 75   D835 23           	inc hl
 76   D836 EB           	ex de,hl
 77   D837 CD 42 D8     	call converthex
 78   D83A              	; hl is index read from string so convert to pointer in range 0x8000-0xBFFF
 79   D83A 29           	add hl,hl ; 2 bytes per index!
 80   D83B 3E 3F        	ld a,0x3F
 81   D83D A4           	and h
 82   D83E F6 80        	or 128
 83   D840 67           	ld h,a
 84   D841 C9           	ret
 85   D842
 86   D842
 87   D842              converthex:
 88   D842 21 00 00     	ld hl,0
 89   D845              .loop:
 90   D845              	; if no characters left we return
 91   D845 78           	ld a,b
 92   D846 B7           	or a
 93   D847 C8           	ret z
 94   D848
 95   D848              	; otherwise get the next character
 96   D848              	; and adjust pointer and counter
 97   D848 1A           	ld a,(de)
 98   D849 13           	inc de
 99   D84A 05           	dec b
100   D84B
101   D84B              	; check if it is a valid hex digit '0-9A-F'
102   D84B D6 30        	sub a,'0'
103   D84D D8           	ret c ;end of convertion
104   D84E FE 0A        	cp 10
105   D850 38 05        	jr c,.addvalue
106   D852 D6 07        	sub a,7
107   D854 FE 10        	cp 16
108   D856 D0           	ret nc ;end of convertion
109   D857              .addvalue:	; digit is now in A
110   D857 29           	add hl,hl
111   D858 29           	add hl,hl
112   D859 29           	add hl,hl
113   D85A 29           	add hl,hl
114   D85B D5           	push de
115   D85C 16 00        	ld d,0
116   D85E 5F           	ld e,a
117   D85F 19           	add hl,de
118   D860 D1           	pop de
119   D861 18 E2        	jr .loop
120   D863
121   D863
# file closed: defusr.asm
