# file opened: defusr.asm
  1   0000              ; routine to read and store integers in memory mapper pages
  2   0000              ; to store a value in a mapper: _usr0("VFFFF,FF33"), where
  3   0000              ; - the first char is a capital letter V..Z
  4   0000              ; - then the index in the array in capital hex
  5   0000              ; - a seperator that determines the end of the hex value, aka something that can't be used as an HEX digit :-)
  6   0000              ; - then the 16bit value to store
  7   0000              ;
  8   0000              ; to read a value in a mapper: _usr1("VFFFF"), where
  9   0000              ; - the first char is a capital letter V..Z
 10   0000              ; - then the index in the array
 11   0000              ;
 12   0000              ;
 13   0000              ; So you can do in basic _USR0("U"+hex$(c)+","+hex$(v))
 14   0000
 15   0000              DAC	equ 0xF7F6 ; 8 bytes containing the data of the variable
 16   0000              VALTYP	equ 0xF663 ; 1 byte indicate the type of variable in DAC
 17   0000              		;VALTYP can be
 18   0000              		; 2 = Integer
 19   0000              		;	DAC byte 0+1 is the 16bits integer
 20   0000              		; 3 = String
 21   0000              		;   DAC byte 2+3 is pointer to string descriptor
 22   0000              		;	  descriptor byte 0 is number of chars
 23   0000              		;	  descriptor byte 1+2 pointer to string storage
 24   0000              		; 4 = Single precision
 25   0000              		;	DAC byte 0+1+2+3 single precision real number
 26   0000              		; 8 = Double precision
 27   0000              		;	DAC byte 0..7 double precision real number
 28   0000
 29   0000
 30   0000              	org 0xc000
 31   C000
 32   C000 18 11        	jr store
 33   C002
 34   C002              retrieve:
 35   C002 CD 25 C0     	call set_mmpage_get_indx_ptr
 36   C005 5E           	ld e,(hl)	; read 16bit value at indx_ptr
 37   C006 23           	inc hl
 38   C007 56           	ld d,(hl)
 39   C008 ED 53 F8 F7  	ld (DAC+2),de	; store in DAC
 40   C00C 3E 02        	ld a,2
 41   C00E 32 63 F6     	ld (VALTYP),a	; set return type to int
 42   C011 18 0C        	jr back2basic
 43   C013
 44   C013              store:
 45   C013 CD 25 C0     	call set_mmpage_get_indx_ptr
 46   C016 E5           	push hl
 47   C017 CD 42 C0     	call converthex
 48   C01A EB           	ex de,hl
 49   C01B E1           	pop hl
 50   C01C 73           	ld (hl),e
 51   C01D 23           	inc hl
 52   C01E 72           	ld (hl),d
 53   C01F              back2basic:
 54   C01F 3E 01        	ld a,1
 55   C021 D3 FE        	out (0xFE),a
 56   C023 FB           	ei
 57   C024 C9           	ret
 58   C025
 59   C025              set_mmpage_get_indx_ptr:
 60   C025              	; get string pointer to interprete
 61   C025              	; no input validation simply assume it is a string...
 62   C025 2A F8 F7     	ld hl,(DAC+2)
 63   C028
 64   C028 46           	ld b,(hl)
 65   C029 23           	inc hl
 66   C02A 5E           	ld e,(hl)
 67   C02B 23           	inc hl
 68   C02C 56           	ld d,(hl)
 69   C02D EB           	ex de,hl
 70   C02E 7E           	ld a,(hl)
 71   C02F 05           	dec b
 72   C030 D6 53        	sub a,'V'-3 ; =>V=3,W=4,X=5,Y=6,Z=7
 73   C032 F3           	di
 74   C033 D3 FE        	out (#FE),a
 75   C035 23           	inc hl
 76   C036 EB           	ex de,hl
 77   C037 CD 42 C0     	call converthex
 78   C03A              	; hl is index read from string so convert to pointer in range 0x8000-0xBFFF
 79   C03A 29           	add hl,hl ; 2 bytes per index!
 80   C03B 3E 3F        	ld a,0x3F
 81   C03D A4           	and h
 82   C03E F6 80        	or 128
 83   C040 67           	ld h,a
 84   C041 C9           	ret
 85   C042
 86   C042
 87   C042              converthex:
 88   C042 21 00 00     	ld hl,0
 89   C045              .loop:
 90   C045              	; if no characters left we return
 91   C045 78           	ld a,b
 92   C046 B7           	or a
 93   C047 C8           	ret z
 94   C048
 95   C048              	; otherwise get the next character
 96   C048              	; and adjust pointer and counter
 97   C048 1A           	ld a,(de)
 98   C049 13           	inc de
 99   C04A 05           	dec b
100   C04B
101   C04B              	; check if it is a valid hex digit '0-9A-F'
102   C04B D6 30        	sub a,'0'
103   C04D D8           	ret c ;end of convertion
104   C04E FE 0A        	cp 10
105   C050 38 05        	jr c,.addvalue
106   C052 D6 07        	sub a,7
107   C054 FE 10        	cp 16
108   C056 D0           	ret nc ;end of convertion
109   C057              .addvalue:	; digit is now in A
110   C057 29           	add hl,hl
111   C058 29           	add hl,hl
112   C059 29           	add hl,hl
113   C05A 29           	add hl,hl
114   C05B D5           	push de
115   C05C 16 00        	ld d,0
116   C05E 5F           	ld e,a
117   C05F 19           	add hl,de
118   C060 D1           	pop de
119   C061 18 E2        	jr .loop
120   C063
121   C063
# file closed: defusr.asm
